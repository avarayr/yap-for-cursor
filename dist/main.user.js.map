{
  "version": 3,
  "sources": ["../src/asr/instance.ts", "../node_modules/@aidenlx/esbuild-plugin-inline-worker/dist/utils.js", "inline-worker:/var/folders/wt/r3jjdtb90sl84637qrrd32s00000gn/T/epiw-wfIie4/worker_uKiry.ts", "../src/asr/manager.ts", "../src/config.ts", "../src/ui/dom-selectors.ts", "../src/audio/processing.ts", "_tpkppiz7t:/Users/mika/experiments/cursor-voice/src/styles/styles.css", "../src/ui/mic-button.ts", "../src/main.ts"],
  "sourcesContent": ["import type { AsrInstance } from \"../types\";\n\ndeclare global {\n  interface Window {\n    _currentAsrInstance?: AsrInstance | null;\n  }\n}\n\n/**\n * Sets the current global ASR instance.\n */\nexport function setCurrentAsrInstance(instance: AsrInstance | null) {\n  window._currentAsrInstance = instance;\n}\n\n/**\n * Gets the current global ASR instance.\n */\nexport function getCurrentAsrInstance(): AsrInstance | null {\n  return window._currentAsrInstance ?? null;\n}\n", "/**\n * @param script code of worker script\n */\nexport const toObjectURL = (script) => {\n    const blob = new Blob([script], { type: \"text/javascript\" });\n    const url = URL.createObjectURL(blob);\n    return url;\n};\n/**\n * @param script code of worker script\n */\nexport const fromScriptText = (script, options) => {\n    const url = toObjectURL(script);\n    const worker = new Worker(url, options);\n    URL.revokeObjectURL(url);\n    return worker;\n};\nexport const fromDataURI = (uri, options) => {\n    const worker = new Worker(uri, options);\n    return worker;\n};\n", "var F=Object.defineProperty,x=Object.defineProperties;var C=Object.getOwnPropertyDescriptors;var T=Object.getOwnPropertySymbols;var G=Object.prototype.hasOwnProperty,E=Object.prototype.propertyIsEnumerable;var m=(e,o,r)=>o in e?F(e,o,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[o]=r,W=(e,o)=>{for(var r in o||(o={}))G.call(o,r)&&m(e,r,o[r]);if(T)for(var r of T(o))E.call(o,r)&&m(e,r,o[r]);return e},h=(e,o)=>x(e,C(o));var i=(e,o,r)=>m(e,typeof o!=\"symbol\"?o+\"\":o,r);console.log(\"[Worker] Code execution started.\");var d=!1,f,y,w,P,v,p;async function A(){console.log(\"[Worker] Initializing Transformers library...\");try{let e=await import(\"https://cdn.jsdelivr.net/npm/@huggingface/transformers@3.5.0\");console.log(\"[Worker] Transformers library imported successfully.\"),f=e.AutoTokenizer,y=e.AutoProcessor,w=e.WhisperForConditionalGeneration,P=e.TextStreamer,v=e.full,p=e.env,p.allowLocalModels=!1,p.backends.onnx.logLevel=\"info\"}catch(e){throw console.error(\"[Worker] Failed to import Transformers library:\",e),e}}var L=128,t=class{static async getInstance(o){if(f||await A(),this.model_id=\"onnx-community/whisper-base\",!this.modelPromise){let s=[f.from_pretrained(this.model_id,{progress_callback:o}),y.from_pretrained(this.model_id,{progress_callback:o}),w.from_pretrained(this.model_id,{dtype:{encoder_model:\"fp32\",decoder_model_merged:\"q4\"},device:\"webgpu\",progress_callback:o})];this.modelPromise=Promise.all(s).then(async a=>{this.tokenizer=a[0],this.processor=a[1],this.model=a[2];try{await this.model.generate({input_features:v([1,80,3e3],0),max_new_tokens:1})}catch(n){return console.warn(\"[Worker] Model warmup failed:\",n),Promise.resolve()}return Promise.resolve()}).then(()=>{if(!this.tokenizer||!this.processor||!this.model)throw new Error(\"[Worker] Model components not initialized correctly after load.\");return[this.tokenizer,this.processor,this.model]}).catch(a=>{throw console.error(\"[Worker] Model loading failed:\",a),this.modelPromise=null,a})}return await this.modelPromise}};i(t,\"model_id\",null),i(t,\"tokenizer\",null),i(t,\"processor\",null),i(t,\"model\",null),i(t,\"modelPromise\",null);var k=!1;async function R({audio:e,language:o}){if(k){console.warn(\"[Worker] Already processing audio.\"),self.postMessage({status:\"error\",data:\"Already processing audio.\"});return}if(!e){console.warn(\"[Worker] No audio data received.\"),self.postMessage({status:\"error\",data:\"No audio data received.\"});return}k=!0,d=!1,console.log(\"[Worker] Transcribing audio...\"),self.postMessage({status:\"transcribing_start\"});try{console.log(\"[Worker] Getting model instance...\");let[r,s,a]=await t.getInstance(l=>{console.log(\"[Worker] AutomaticSpeechRecognitionPipeline Progress callback:\",l)});console.log(\"[Worker] Model instance retrieved.\");let n=null,c=0,u=\"\",M=l=>{if(d){console.log(\"[Worker] Streamer callback cancelled.\");return}n!=null||(n=performance.now()),u=l;let g=0;c++>0&&n&&(g=c/(performance.now()-n)*1e3);let b={status:\"update\",output:u,tps:g?parseFloat(g.toFixed(1)):0,numTokens:c};self.postMessage(b)};console.log(\"[Worker] Creating text streamer...\");let _=new P(r,{skip_prompt:!0,skip_special_tokens:!0,callback_function:M});console.log(\"[Worker] Text streamer created.\");let z=await s(e);if(console.log(\"[Worker] Processor inputs created.\"),await a.generate(h(W({},z),{max_new_tokens:L,language:o,streamer:_})),console.log(\"[Worker] Model generate completed.\"),d)console.log(\"[Worker] Transcription cancelled post-generation. Discarding result.\");else{let l={status:\"complete\",output:u};console.log(\"[Worker] Sending complete message.\",l),self.postMessage(l)}}catch(r){console.error(\"[Worker] Transcription failed:\",r),self.postMessage({status:\"error\",data:`Transcription failed: ${Error.isError(r)?r.message:\"unknown error\"}`})}finally{k=!1}}console.log(\"[Worker] Setting up message listener.\");self.addEventListener(\"message\",async e=>{if(console.log(\"[Worker] Received message:\",e.data),!e.data||typeof e.data!=\"object\"||!(\"type\"in e.data)){console.warn(\"[Worker] Received invalid message format:\",e.data);return}let{type:o,data:r}=e.data;switch(o){case\"load\":console.log(\"[Worker] Handling 'load' message.\");try{console.log(\"[Worker] Attempting to get/load model instance...\"),await t.getInstance(s=>{s.status===\"progress\"?self.postMessage({status:\"loading\",data:`Loading model: ${s.progress.toFixed(0)}%`}):(s.status===\"done\"||s.status===\"ready\")&&self.postMessage({status:\"ready\"})}),console.log(\"[Worker] Model instance loaded/retrieved successfully.\")}catch(s){console.error(\"[Worker] Error during model loading on 'load' message:\",s)}break;case\"generate\":r?(console.log(\"[Worker] Received 'generate' message with data:\",r),await R(r)):console.warn(\"[Worker] 'generate' message received without data.\");break;case\"stop\":console.log(\"[Worker] Received stop message.\"),d=!0;break;default:console.warn(\"[Worker] Received unknown message type:\",o);break}});console.log(\"[Worker] Message listener set up. Initial script execution complete.\");\n//# sourceMappingURL=worker_uKiry.ts.map\n", "import type {\n  AsrStatusUpdateDetail,\n  WorkerMessage,\n  WorkerResponse,\n  AsrResultDetail,\n} from \"../types\";\nimport { fromScriptText } from \"@aidenlx/esbuild-plugin-inline-worker/utils\";\nimport WorkerCode from \"worker:./worker.ts\";\n\n// Define navigator with gpu property\ninterface NavigatorWithGPU extends Navigator {\n  gpu?: {\n    requestAdapter: () => Promise<GPUAdapter | null>;\n  };\n}\n\ninterface GPUAdapter {\n  requestDevice: () => Promise<GPUDevice>;\n}\n\ninterface GPUDevice {\n  createCommandEncoder: () => GPUCommandEncoder;\n}\n\ninterface GPUCommandEncoder {\n  finish: () => GPUCommandBuffer;\n}\n\ninterface GPUCommandBuffer {}\n\ndeclare const navigator: NavigatorWithGPU;\n\n// --- Global ASR Status Management ---\nexport let globalAsrStatus: AsrStatusUpdateDetail[\"status\"] | \"uninitialized\" =\n  \"uninitialized\";\nexport let globalAsrMessage: string = \"Click to initialize\";\n\n// --- Worker Instance Management ---\nlet worker: Worker | null = null;\nlet workerReady: boolean = false;\nlet workerLoading: boolean = false;\nlet workerError: string | null = null;\nlet currentWorkerUrl: string | null = null;\n\n/**\n * Dispatches a global ASR status update event.\n */\nfunction dispatchStatusUpdate(\n  status: AsrStatusUpdateDetail[\"status\"] | \"uninitialized\",\n  message?: string\n) {\n  globalAsrStatus = status;\n  globalAsrMessage =\n    message ||\n    (status === \"ready\"\n      ? \"ASR Ready\"\n      : status === \"error\"\n      ? `ASR Error: ${workerError || \"Unknown\"}`\n      : status === \"loading\"\n      ? \"Loading ASR model...\"\n      : status === \"initializing\"\n      ? \"Initializing ASR...\"\n      : status === \"uninitialized\"\n      ? \"Click mic to initialize\"\n      : \"ASR status unknown\");\n  console.log(`ASR Status: ${status}`, message ? `(${message})` : \"\");\n  const detail: AsrStatusUpdateDetail = {\n    status: status === \"uninitialized\" ? \"initializing\" : status,\n    message: globalAsrMessage,\n  };\n  document.dispatchEvent(\n    new CustomEvent<AsrStatusUpdateDetail>(\"asrStatusUpdate\", { detail })\n  );\n}\n\n/**\n * Creates or returns the existing ASR worker instance.\n * Should only be called internally by triggerASRInitialization.\n */\nfunction getOrCreateWorker(): Worker | null {\n  console.log(\"[ASR Manager] getOrCreateWorker called.\");\n  if (worker) {\n    console.warn(\n      \"[ASR Manager] getOrCreateWorker called when worker already exists.\"\n    );\n    return worker;\n  }\n  if (workerLoading) {\n    console.warn(\n      \"[ASR Manager] getOrCreateWorker called while already loading.\"\n    );\n    return null;\n  }\n  if (workerError) {\n    dispatchStatusUpdate(\"error\", workerError);\n    return null;\n  }\n  if (!navigator.gpu) {\n    console.error(\n      \"[ASR Manager] getOrCreateWorker called but WebGPU not supported.\"\n    );\n    workerError = \"WebGPU not supported\";\n    dispatchStatusUpdate(\"error\", workerError);\n    return null;\n  }\n\n  workerLoading = true;\n  console.log(\"[ASR Manager] Attempting to create worker...\");\n  dispatchStatusUpdate(\"loading\", \"Creating ASR Worker...\");\n\n  try {\n    if (currentWorkerUrl) {\n      URL.revokeObjectURL(currentWorkerUrl);\n      currentWorkerUrl = null;\n    }\n    worker = fromScriptText(WorkerCode, {});\n\n    worker.onmessage = (e: MessageEvent<WorkerResponse>) => {\n      const { status, data, ...rest } = e.data;\n      console.log(\"[ASR Manager] Received message from worker:\", e.data);\n      switch (status) {\n        case \"loading\":\n          dispatchStatusUpdate(\"loading\", data);\n          break;\n        case \"ready\":\n          workerReady = true;\n          workerLoading = false;\n          workerError = null;\n          dispatchStatusUpdate(\"ready\");\n          break;\n        case \"error\":\n          console.error(\n            \"[ASR Manager] Received error status from Worker:\",\n            data\n          );\n          workerError = data || \"Unknown worker error\";\n          workerLoading = false;\n          workerReady = false;\n          dispatchStatusUpdate(\"error\", workerError);\n          worker?.terminate();\n          worker = null;\n          if (currentWorkerUrl) {\n            URL.revokeObjectURL(currentWorkerUrl);\n            currentWorkerUrl = null;\n          }\n          break;\n        default:\n          document.dispatchEvent(\n            new CustomEvent<AsrResultDetail>(\"asrResult\", {\n              detail: { status, ...rest, data },\n            })\n          );\n          break;\n      }\n    };\n\n    worker.onerror = (err: ErrorEvent) => {\n      console.error(\n        \"[ASR Manager] Unhandled Worker Error event:\",\n        err.message,\n        err\n      );\n      workerError = err.message || \"Unhandled worker error\";\n      workerLoading = false;\n      workerReady = false;\n      dispatchStatusUpdate(\"error\", `Worker failed: ${workerError}`);\n      worker?.terminate();\n      worker = null;\n      if (currentWorkerUrl) {\n        URL.revokeObjectURL(currentWorkerUrl);\n        currentWorkerUrl = null;\n      }\n    };\n\n    console.log(\n      \"[ASR Manager] Worker instance created, sending initial load message.\"\n    );\n    const initialMessage: WorkerMessage = { type: \"load\" };\n    worker.postMessage(initialMessage);\n  } catch (error: any) {\n    console.error(\"[ASR Manager] Failed to instantiate worker:\", error);\n    workerError = `Failed to create worker: ${error.message || error}`;\n    workerLoading = false;\n    dispatchStatusUpdate(\"error\", workerError);\n    worker = null;\n    if (currentWorkerUrl) {\n      URL.revokeObjectURL(currentWorkerUrl);\n      currentWorkerUrl = null;\n    }\n  }\n\n  return worker;\n}\n\n/**\n * Checks WebGPU support and sets initial status. Does not load the worker.\n */\nexport function initializeASRSystem(): void {\n  console.log(\n    \"[ASR Manager] initializeASRSystem called (passive initialization).\"\n  );\n  if (!navigator.gpu) {\n    console.warn(\"[ASR Manager] WebGPU not supported. ASR will be disabled.\");\n    workerError = \"WebGPU not supported\";\n    dispatchStatusUpdate(\"error\", workerError);\n  } else {\n    console.log(\n      \"[ASR Manager] WebGPU supported. ASR is ready to be loaded on demand.\"\n    );\n    if (globalAsrStatus !== \"error\") {\n      dispatchStatusUpdate(\"uninitialized\");\n    }\n  }\n}\n\n/**\n * Called by UI elements (e.g., mic button) to trigger the actual\n * ASR worker creation and model loading if it hasn't happened yet.\n */\nexport function triggerASRInitialization(): void {\n  console.log(\"[ASR Manager] triggerASRInitialization called.\");\n  if (globalAsrStatus === \"uninitialized\" && !workerError) {\n    console.log(\n      \"[ASR Manager] ASR is uninitialized, proceeding to load worker.\"\n    );\n    if (!navigator.gpu) {\n      console.error(\n        \"[ASR Manager] Triggered initialization but WebGPU not supported.\"\n      );\n      workerError = \"WebGPU not supported\";\n      dispatchStatusUpdate(\"error\", workerError);\n      return;\n    }\n    getOrCreateWorker();\n  } else if (workerLoading) {\n    console.log(\"[ASR Manager] Initialization already in progress.\");\n  } else if (workerReady) {\n    console.log(\"[ASR Manager] ASR already initialized and ready.\");\n  } else if (workerError) {\n    console.log(\n      \"[ASR Manager] Cannot initialize due to previous error:\",\n      workerError\n    );\n    dispatchStatusUpdate(\"error\", workerError);\n  } else {\n    console.warn(\n      \"[ASR Manager] triggerASRInitialization called in unexpected state:\",\n      globalAsrStatus\n    );\n  }\n}\n\n/**\n * Sends audio data to the worker for transcription if the worker is ready.\n * @param audioData The Float32Array containing the audio samples.\n * @param language The target language for transcription.\n */\nexport function requestTranscription(\n  audioData: Float32Array,\n  language: string\n): void {\n  console.log(\"[ASR Manager] requestTranscription called.\");\n  if (isWorkerReady() && worker) {\n    console.log(\"[ASR Manager] Worker is ready, posting generate message.\");\n    const message: WorkerMessage = {\n      type: \"generate\",\n      data: {\n        audio: audioData,\n        language: language,\n      },\n    };\n    worker.postMessage(message);\n  } else if (!worker) {\n    console.error(\n      \"[ASR Manager] Transcription requested, but worker does not exist.\"\n    );\n    dispatchStatusUpdate(\"error\", \"Worker instance missing\");\n  } else if (workerLoading) {\n    console.warn(\n      \"[ASR Manager] Transcription requested, but worker is still loading.\"\n    );\n  } else if (workerError) {\n    console.error(\n      \"[ASR Manager] Transcription requested, but worker is in error state:\",\n      workerError\n    );\n    dispatchStatusUpdate(\"error\", workerError);\n  } else {\n    console.warn(\n      \"[ASR Manager] Transcription requested, but worker is not ready for unknown reasons.\"\n    );\n  }\n}\n\n/** Checks if the ASR worker is ready for transcription tasks. */\nexport function isWorkerReady(): boolean {\n  return !!worker && workerReady && !workerLoading && !workerError;\n}\n\n/** Gets the current worker error message, if any. */\nexport function getWorkerError(): string | null {\n  return workerError;\n}\n\n/**\n * Sends a message to the worker to stop the current transcription.\n */\nexport function stopWorkerTranscription(): void {\n  if (worker && workerReady) {\n    console.log(\"[ASR Manager] Sending stop message to worker.\");\n    const stopMessage: WorkerMessage = { type: \"stop\" };\n    worker.postMessage(stopMessage);\n  } else {\n    console.warn(\n      \"[ASR Manager] Cannot send stop message: Worker not ready or doesn't exist.\"\n    );\n  }\n}\n", "export const HUGGING_FACE_TRANSFORMERS_VERSION = \"3.5.0\"; // Or latest compatible\nexport const TARGET_SAMPLE_RATE = 16000; // Whisper expects 16kHz\nexport const ASR_LANGUAGE = \"english\"; // Specify language for transcription\nexport const MAX_NEW_TOKENS = 128; // Max tokens for ASR output\n", "/**\n * Centralized DOM selectors for ASR UI components.\n * Update these in one place if the DOM structure changes.\n */\nexport const DOM_SELECTORS = {\n  micButton: \".mic-btn[data-asr-init]\",\n  chatInputContentEditable: \".aislash-editor-input[contenteditable='true']\",\n  fullInputBox: \".full-input-box\",\n  buttonContainer: \".button-container.composer-button-area\",\n};\n", "import { TARGET_SAMPLE_RATE } from \"../config\";\n\n/**\n * Processes an audio Blob, decodes it, and resamples it to the target sample rate if necessary.\n * Returns a mono Float32Array suitable for the ASR model.\n *\n * @param blob The input audio Blob.\n * @param targetSr The target sample rate (default: TARGET_SAMPLE_RATE).\n * @returns A Promise that resolves to a Float32Array or null if processing fails.\n */\nexport async function processAudioBlob(\n  blob: Blob | null,\n  targetSr: number = TARGET_SAMPLE_RATE\n): Promise<Float32Array | null> {\n  if (!blob || blob.size === 0) return null;\n\n  // Correctly reference AudioContext\n  const AudioContext = window.AudioContext;\n  if (!AudioContext) {\n    console.error(\"Browser does not support AudioContext.\");\n    return null;\n  }\n  const audioContext = new AudioContext();\n\n  try {\n    const arrayBuffer = await blob.arrayBuffer();\n    const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);\n\n    if (audioBuffer.sampleRate === targetSr) {\n      // No resampling needed\n      await audioContext.close(); // Close context when done\n      // Ensure mono by taking the first channel\n      return audioBuffer.getChannelData(0);\n    }\n\n    // Resampling needed\n    console.log(`Resampling from ${audioBuffer.sampleRate}Hz to ${targetSr}Hz`);\n    const duration = audioBuffer.duration;\n    const offlineContext = new OfflineAudioContext(\n      1, // Mono\n      Math.ceil(duration * targetSr), // Calculate output buffer size correctly\n      targetSr\n    );\n    const bufferSource = offlineContext.createBufferSource();\n    bufferSource.buffer = audioBuffer;\n    bufferSource.connect(offlineContext.destination);\n    bufferSource.start();\n\n    const resampledBuffer = await offlineContext.startRendering();\n    await audioContext.close(); // Close original context\n    return resampledBuffer.getChannelData(0); // Return Float32Array of the first (only) channel\n  } catch (error) {\n    console.error(\"Audio processing failed:\", error);\n    if (audioContext && audioContext.state !== \"closed\") {\n      await audioContext.close();\n    }\n    return null;\n  }\n}\n", ".sv-wrap {\n  width: 0;\n  height: 24px;\n  opacity: 0;\n  overflow: hidden;\n  transition: width 0.3s ease, opacity 0.3s ease;\n  margin-right: 2px;\n  border-radius: 4px;\n  vertical-align: middle;\n  display: inline-block;\n  position: relative;\n  mask-image: linear-gradient(\n    to right,\n    transparent 0,\n    black 10px,\n    black calc(100% - 10px),\n    transparent 100%\n  );\n}\n.mic-btn {\n  cursor: pointer;\n  padding: 4px;\n  border-radius: 50%;\n  transition: background 0.2s, color 0.2s;\n  display: inline-flex;\n  align-items: center;\n  justify-content: center;\n  vertical-align: middle;\n  position: relative;\n  color: #888;\n}\n.mic-btn:hover {\n  background: rgba(0, 0, 0, 0.05);\n  color: #555;\n}\n.mic-btn.active {\n  color: #e66;\n  background: rgba(255, 100, 100, 0.1);\n}\n.mic-btn.transcribing {\n  color: #0cf;\n  background: rgba(0, 200, 255, 0.1);\n}\n.mic-btn.disabled {\n  cursor: not-allowed;\n  color: #bbb;\n  background: transparent !important;\n}\n@keyframes sv-spin {\n  from {\n    transform: rotate(0);\n  }\n  to {\n    transform: rotate(360deg);\n  }\n}\n.mic-spinner {\n  width: 12px;\n  height: 12px;\n  border: 2px solid rgba(0, 0, 0, 0.2);\n  border-top-color: #0cf;\n  border-radius: 50%;\n  animation: sv-spin 1s linear infinite;\n}\n.mic-btn.disabled .mic-spinner {\n  border-top-color: #ccc;\n}\n.mic-btn.transcribing .mic-spinner {\n  border-top-color: #0cf;\n}\n.mic-btn .status-tooltip {\n  visibility: hidden;\n  width: 120px;\n  background-color: #555;\n  color: #fff;\n  text-align: center;\n  border-radius: 6px;\n  padding: 5px 3px;\n  position: absolute;\n  z-index: 1;\n  bottom: 125%;\n  left: 50%;\n  margin-left: -60px;\n  opacity: 0;\n  transition: opacity 0.3s;\n  font-size: 10px;\n}\n.mic-btn .status-tooltip::after {\n  content: \"\";\n  position: absolute;\n  top: 100%;\n  left: 50%;\n  margin-left: -5px;\n  border-width: 5px;\n  border-style: solid;\n  border-color: #555 transparent transparent transparent;\n}\n.mic-btn:hover .status-tooltip,\n.mic-btn.disabled .status-tooltip {\n  visibility: visible;\n  opacity: 1;\n}\n/* Styles for the cancel button - mimicking mic-btn but red */\n.sv-cancel-btn {\n  cursor: pointer;\n  padding: 4px;\n  border-radius: 50%;\n  transition: background 0.2s, color 0.2s;\n  display: inline-flex;\n  align-items: center;\n  justify-content: center;\n  vertical-align: middle;\n  color: #e66;\n  margin-right: 2px;\n}\n.sv-cancel-btn:hover {\n  background: rgba(255, 100, 100, 0.1);\n  color: #c33; /* Darker red on hover */\n}\n/* Styles for transcribing state controls */\n.transcribe-controls {\n  display: inline-flex;\n  align-items: center;\n  justify-content: center;\n  gap: 4px;\n}\n.stop-btn-style {\n  color: #e66;\n  cursor: pointer;\n  font-size: 10px;\n}\n", "import { setCurrentAsrInstance } from \"../asr/instance\";\nimport {\n  globalAsrMessage as currentAsrMessage,\n  globalAsrStatus as currentAsrStatus,\n  isWorkerReady,\n  requestTranscription,\n  stopWorkerTranscription,\n  triggerASRInitialization,\n} from \"../asr/manager\";\nimport { processAudioBlob } from \"../audio/processing\";\nimport * as CONFIG from \"../config\";\nimport type {\n  AsrStatusUpdateDetail,\n  MicButtonElement,\n  MicButtonState,\n} from \"../types\";\nimport { DOM_SELECTORS } from \"./dom-selectors\";\nimport styles from \"inline:../styles/styles.css\";\n\n// --- Shared CSS Injection ---\nconst styleId = \"fadein-width-bar-wave-styles\";\nfunction injectGlobalStyles(): void {\n  if (!document.getElementById(styleId)) {\n    const s = document.createElement(\"style\");\n    s.id = styleId;\n    s.textContent = styles;\n    document.head.appendChild(s);\n  }\n}\n\n// --- Mic Button State Update ---\nexport function updateMicButtonState(\n  button: MicButtonElement | null,\n  newState: MicButtonState,\n  message: string = \"\"\n): void {\n  if (!button) return;\n\n  // Read the *global* ASR status from the manager\n  const actualAsrStatus = currentAsrStatus;\n  const actualAsrMessage = currentAsrMessage;\n\n  // Determine the effective state for the UI based on global status\n  let effectiveState: MicButtonState | \"loading\" | \"uninitialized\" = newState; // Allow internal state but override based on global\n  let displayMessage = message; // Message specifically passed to this function\n\n  if (actualAsrStatus === \"uninitialized\") {\n    effectiveState = \"uninitialized\";\n    displayMessage = actualAsrMessage || \"Click to load ASR\";\n  } else if (\n    actualAsrStatus === \"initializing\" ||\n    actualAsrStatus === \"loading\"\n  ) {\n    effectiveState = \"loading\"; // Treat both as a visual loading state\n    displayMessage = actualAsrMessage;\n  } else if (actualAsrStatus === \"error\") {\n    effectiveState = \"disabled\";\n    displayMessage = `ASR Error: ${actualAsrMessage}`;\n  } else if (actualAsrStatus !== \"ready\" && newState !== \"transcribing\") {\n    // If global status isn't ready, but we aren't actively transcribing, treat as disabled\n    // This handles edge cases where internal state might be 'idle' but manager isn't 'ready'\n    effectiveState = \"disabled\";\n    displayMessage = actualAsrMessage || \"ASR not ready\";\n  } else if (newState === \"transcribing\") {\n    // If the requested state is transcribing, keep it, assuming manager is ready or will be soon\n    effectiveState = \"transcribing\";\n    displayMessage = message || \"Transcribing...\";\n  } else if (newState === \"recording\") {\n    // If requesting recording, ensure manager is ready\n    if (actualAsrStatus === \"ready\") {\n      effectiveState = \"recording\";\n      displayMessage = message || \"Recording...\";\n    } else {\n      // Cannot record if manager isn't ready\n      effectiveState = \"disabled\";\n      displayMessage = actualAsrMessage || \"ASR not ready\";\n    }\n  } else {\n    // Default to idle if manager is ready and no other state applies\n    effectiveState = \"idle\";\n    displayMessage = message || \"Hold to Record, Release to Transcribe\";\n  }\n\n  // Update button's internal state marker if needed (optional)\n  button.asrState =\n    effectiveState === \"uninitialized\" || effectiveState === \"loading\"\n      ? \"idle\"\n      : (effectiveState as MicButtonState); // Cast 'idle'|'recording'|'transcribing'|'disabled'\n\n  button.classList.remove(\"active\", \"transcribing\", \"disabled\");\n  button.innerHTML = \"\"; // Clear previous content\n\n  // Ensure tooltip exists\n  let tooltip = button.querySelector<HTMLSpanElement>(\".status-tooltip\");\n  if (!tooltip) {\n    tooltip = document.createElement(\"span\");\n    tooltip.className = \"status-tooltip\";\n    button.appendChild(tooltip);\n  }\n\n  let iconClass = \"\";\n  let defaultTitle = \"\";\n\n  switch (effectiveState) {\n    case \"recording\":\n      button.classList.add(\"active\");\n      iconClass = \"codicon-primitive-square\";\n      defaultTitle = displayMessage;\n      break;\n    case \"transcribing\":\n      button.classList.add(\"transcribing\");\n      // Container for spinner and stop button\n      const transcribeControlContainer = document.createElement(\"div\");\n      transcribeControlContainer.className = \"transcribe-controls\"; // Apply class\n\n      const spinnerT = document.createElement(\"div\");\n      spinnerT.className = \"mic-spinner\";\n      transcribeControlContainer.appendChild(spinnerT);\n\n      // Add Stop button (X icon)\n      const stopBtn = document.createElement(\"span\");\n      // Apply style class along with codicon classes\n      stopBtn.className =\n        \"codicon codicon-x stop-transcription-btn stop-btn-style\"; // Added stop-btn-style class\n      stopBtn.setAttribute(\"title\", \"Stop Transcription\");\n      transcribeControlContainer.appendChild(stopBtn);\n\n      button.appendChild(transcribeControlContainer);\n      defaultTitle = displayMessage;\n      iconClass = \"\"; // No main icon when spinner/stop are shown\n      break;\n    case \"loading\": // New visual state for loading/initializing\n      button.classList.add(\"disabled\"); // Treat visually as disabled during load\n      const spinnerL = document.createElement(\"div\");\n      spinnerL.className = \"mic-spinner\";\n      button.appendChild(spinnerL);\n      defaultTitle = displayMessage;\n      iconClass = \"\";\n      break;\n    case \"disabled\":\n      button.classList.add(\"disabled\");\n      // Keep spinner if the *reason* for disabled is loading/init (handled by 'loading' case now)\n      if (actualAsrStatus === \"error\") {\n        iconClass = \"codicon-error\";\n      } else {\n        // Default disabled icon if not error or loading\n        iconClass = \"codicon-mic-off\";\n      }\n      defaultTitle = displayMessage;\n      break;\n    case \"uninitialized\": // New visual state for uninitialized\n      // Visually similar to idle, but different tooltip\n      iconClass = \"codicon-mic\";\n      defaultTitle = displayMessage;\n      break;\n    case \"idle\":\n    default:\n      iconClass = \"codicon-mic\";\n      defaultTitle = displayMessage;\n      break;\n  }\n\n  if (iconClass) {\n    const icon = document.createElement(\"span\");\n    icon.className = `codicon ${iconClass} !text-[12px]`;\n    // Ensure icon is added before the tooltip if tooltip was recreated\n    if (tooltip && tooltip.parentNode !== button) {\n      button.appendChild(icon);\n      button.appendChild(tooltip);\n    } else if (tooltip) {\n      button.insertBefore(icon, tooltip);\n    } else {\n      button.appendChild(icon);\n    }\n  }\n\n  // Update tooltip content and button title attribute\n  if (tooltip) {\n    tooltip.textContent = defaultTitle;\n  }\n  button.setAttribute(\"title\", defaultTitle);\n\n  // Re-append tooltip if it wasn't already there (might have been cleared)\n  if (!button.querySelector(\".status-tooltip\") && tooltip) {\n    button.appendChild(tooltip);\n  }\n}\n\n// --- Initialization for each Mic Instance ---\nexport function initWave(box: HTMLElement): void {\n  if (box.dataset.waveInit) return;\n  box.dataset.waveInit = \"1\";\n\n  const area = box.querySelector<HTMLDivElement>(DOM_SELECTORS.buttonContainer);\n  const chatInputContentEditable = box.querySelector<HTMLDivElement>(\n    DOM_SELECTORS.chatInputContentEditable\n  );\n\n  if (!area || !chatInputContentEditable) {\n    console.warn(\n      \"Could not find button area or chatInputContentEditable for\",\n      box\n    );\n    return;\n  }\n\n  // Build DOM\n  const wrap = document.createElement(\"div\");\n  wrap.className = \"sv-wrap\";\n  wrap.style.opacity = \"0\";\n\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = 120;\n  canvas.height = 24;\n  wrap.appendChild(canvas);\n\n  // --- Add cancel button (trash icon) ---\n  const cancelBtn = document.createElement(\"div\"); // Use div for easier styling\n  cancelBtn.className = \"sv-cancel-btn\";\n  cancelBtn.setAttribute(\"title\", \"Cancel and discard recording\");\n  cancelBtn.style.display = \"none\"; // Only show when recording\n  const cancelIcon = document.createElement(\"span\");\n  cancelIcon.className = \"codicon codicon-trash !text-[12px]\";\n  cancelBtn.appendChild(cancelIcon);\n  // ---\n\n  const mic = document.createElement(\"div\") as MicButtonElement;\n  mic.className = \"mic-btn\";\n  mic.dataset.asrInit = \"1\";\n  // Initial state is determined by the manager now, set via updateMicButtonState\n  // mic.asrState = \"idle\"; // Remove this, rely on updateMicButtonState\n  // mic.setAttribute(\"title\", \"Hold to Record, Release to Transcribe\"); // Remove this\n\n  const statusTooltip = document.createElement(\"span\");\n  statusTooltip.className = \"status-tooltip\";\n  mic.appendChild(statusTooltip);\n\n  // Prepend in order: cancel, wrap, mic\n  area.prepend(mic);\n  area.prepend(wrap);\n  area.prepend(cancelBtn);\n\n  // Visualization params\n  const ctx = canvas.getContext(\"2d\");\n  const W = canvas.width,\n    H = canvas.height;\n  const BAR_WIDTH = 2,\n    BAR_GAP = 1,\n    STEP = BAR_WIDTH + BAR_GAP;\n  const SLOTS = Math.floor(W / STEP);\n  const MIN_H = 1,\n    MAX_H = H - 2,\n    SENS = 3.5,\n    SCROLL = 0.5;\n  let amps = new Array(SLOTS).fill(MIN_H);\n  let alphas = new Array(SLOTS).fill(1);\n  let offset = 0;\n\n  // Audio state variables\n  let audioCtx: AudioContext | null = null;\n  let analyser: AnalyserNode | null = null;\n  let dataArr: Uint8Array | null = null;\n  let stream: MediaStream | null = null;\n  let sourceNode: MediaStreamAudioSourceNode | null = null;\n  let raf: number | null = null;\n  let mediaRecorder: MediaRecorder | null = null;\n  let audioChunks: Blob[] = [];\n  let isCancelled = false;\n\n  // Set initial button state based on global status\n  updateMicButtonState(mic, \"idle\"); // Initial call uses 'idle' as base, but will be overridden by global status check inside\n\n  // Listen to global ASR status updates to keep the button current\n  const handleAsrStatusUpdate = (event: Event) => {\n    // Update the button state whenever the global status changes\n    // Pass the current internal state ('idle' is safe default) so updateMicButtonState can decide\n    updateMicButtonState(mic, mic.asrState || \"idle\");\n    // We don't need event.detail here, just the notification that status changed\n    const customEvent = event as CustomEvent<AsrStatusUpdateDetail>; // Cast if needed\n    console.log(\"ASR Status Update Received by Mic:\", customEvent.detail);\n  };\n  document.addEventListener(\n    \"asrStatusUpdate\",\n    handleAsrStatusUpdate as EventListener\n  );\n  // TODO: Consider adding cleanup for this listener if the element is removed\n\n  // --- Internal Helper Functions ---\n  function draw() {\n    if (!analyser || !dataArr || !ctx) return;\n    analyser.getByteTimeDomainData(dataArr);\n    let peak = 0;\n    for (const v of dataArr) peak = Math.max(peak, Math.abs(v - 128) / 128);\n    peak = Math.min(1, peak * SENS);\n    const h = MIN_H + peak * (MAX_H - MIN_H);\n\n    offset += SCROLL;\n    if (offset >= STEP) {\n      offset -= STEP;\n      amps.shift();\n      alphas.shift();\n      amps.push(h);\n      alphas.push(0);\n    }\n\n    ctx.clearRect(0, 0, W, H);\n    ctx.lineWidth = BAR_WIDTH;\n    ctx.lineCap = \"round\";\n\n    for (let i = 0; i < SLOTS; i++) {\n      const barH = amps[i];\n      if (alphas[i] < 1) alphas[i] = Math.min(1, alphas[i] + 0.1);\n      const x = i * STEP - offset + BAR_WIDTH / 2;\n      const y1 = (H - barH) / 2,\n        y2 = y1 + barH;\n      ctx.strokeStyle = \"#0cf\";\n      ctx.globalAlpha = alphas[i];\n      ctx.beginPath();\n      ctx.moveTo(x, y1);\n      ctx.lineTo(x, y2);\n      ctx.stroke();\n    }\n    ctx.globalAlpha = 1;\n    raf = requestAnimationFrame(draw);\n  }\n\n  function stopVisualization() {\n    if (raf !== null) cancelAnimationFrame(raf);\n    raf = null;\n    wrap.style.opacity = \"0\";\n    wrap.style.width = \"0\";\n    setTimeout(() => {\n      // Use mic's internal state, not global status\n      // Linter error fixed here\n      const currentMicState = mic.asrState;\n      if (currentMicState !== \"recording\" && ctx) {\n        ctx.clearRect(0, 0, W, H);\n      }\n    }, 300);\n    amps.fill(MIN_H);\n    alphas.fill(1);\n    offset = 0;\n    sourceNode?.disconnect();\n    analyser = null;\n    sourceNode = null;\n  }\n\n  function stopRecording(forceStop: boolean = false) {\n    // Check the button's *current* visual/intended state, not just manager state\n    const currentMicState = mic.asrState; // Read from the element attribute/property if you store it there\n    if (!forceStop && currentMicState !== \"recording\") return; // Check button's state\n\n    console.log(\"Stopping recording...\");\n    stopVisualization();\n\n    if (mediaRecorder && mediaRecorder.state === \"recording\") {\n      try {\n        mediaRecorder.stop(); // This triggers the onstop handler\n      } catch (e) {\n        console.warn(\"Error stopping MediaRecorder:\", e);\n      }\n    }\n    mediaRecorder = null; // Clear recorder ref *after* stopping\n\n    stream?.getTracks().forEach((track) => track.stop());\n    stream = null;\n\n    audioCtx\n      ?.close()\n      .catch((e) => console.warn(\"Error closing AudioContext:\", e));\n    audioCtx = null;\n\n    cancelBtn.style.display = \"none\"; // Hide cancel when not recording\n\n    // Only update state if forceStop happened without cancellation\n    // The onstop handler will set transcribing/idle otherwise\n    if (forceStop && !isCancelled) {\n      updateMicButtonState(mic, \"idle\", \"Recording stopped\"); // Update state after forced stop\n    }\n    // Don't reset isCancelled here, let onstop handle it\n  }\n\n  // --- startRecording: Now only called when ASR is ready ---\n  function startRecording() {\n    // No need to check status here anymore, mousedown handler does it.\n    // Assume we are in 'ready' state if this function is called.\n\n    console.log(\"Attempting to start recording (ASR should be ready)...\");\n    updateMicButtonState(mic, \"recording\"); // Update UI to recording state\n    audioChunks = [];\n    isCancelled = false; // Reset cancel flag for new recording\n\n    navigator.mediaDevices\n      .getUserMedia({ audio: true })\n      .then((ms) => {\n        if (mic.asrState !== \"recording\") {\n          console.warn(\n            \"Mic state changed away from recording during getUserMedia, aborting.\"\n          );\n          ms.getTracks().forEach((track) => track.stop());\n          updateMicButtonState(mic, \"idle\", \"Recording aborted\");\n          return;\n        }\n        stream = ms;\n        const AudioContext = window.AudioContext;\n        if (!AudioContext) throw new Error(\"AudioContext not supported\");\n        audioCtx = new AudioContext();\n        analyser = audioCtx.createAnalyser();\n        analyser.fftSize = 1024;\n        analyser.smoothingTimeConstant = 0.6;\n        dataArr = new Uint8Array(analyser.frequencyBinCount);\n        sourceNode = audioCtx.createMediaStreamSource(stream);\n        sourceNode.connect(analyser);\n\n        wrap.style.width = `${SLOTS * STEP}px`;\n        wrap.style.opacity = \"1\";\n        raf = requestAnimationFrame(draw);\n\n        cancelBtn.style.display = \"inline-flex\"; // Show cancel when recording\n\n        try {\n          const mimeTypes = [\n            \"audio/webm;codecs=opus\",\n            \"audio/ogg;codecs=opus\",\n            \"audio/wav\",\n            \"audio/mp4\",\n            \"audio/webm\",\n          ];\n          let selectedMimeType: string | undefined = undefined;\n          for (const mimeType of mimeTypes) {\n            if (MediaRecorder.isTypeSupported(mimeType)) {\n              selectedMimeType = mimeType;\n              break;\n            }\n          }\n          if (!selectedMimeType)\n            console.warn(\"Using browser default MIME type.\");\n\n          mediaRecorder = new MediaRecorder(stream, {\n            mimeType: selectedMimeType,\n          });\n\n          mediaRecorder.ondataavailable = (event: BlobEvent) => {\n            if (event.data.size > 0) audioChunks.push(event.data);\n          };\n\n          // --- mediaRecorder.onstop ---\n          mediaRecorder.onstop = async () => {\n            console.log(\"MediaRecorder stopped. isCancelled:\", isCancelled);\n            cancelBtn.style.display = \"none\"; // Hide cancel button\n\n            if (isCancelled) {\n              console.log(\"Recording was cancelled. Discarding audio chunks.\");\n              audioChunks = []; // Clear chunks\n              updateMicButtonState(mic, \"idle\", \"Recording cancelled\");\n              isCancelled = false; // Reset flag\n              return; // Don't process cancelled audio\n            }\n\n            // Proceed with processing if not cancelled\n            if (audioChunks.length === 0) {\n              console.log(\"No audio chunks recorded.\");\n              updateMicButtonState(mic, \"idle\", \"No audio recorded\");\n              return;\n            }\n\n            console.log(\"Processing recorded audio chunks...\");\n            updateMicButtonState(mic, \"transcribing\", \"Processing audio...\"); // Set state to transcribing\n\n            const audioBlob = new Blob(audioChunks, {\n              type: mediaRecorder?.mimeType || \"audio/webm\",\n            });\n            audioChunks = []; // Clear chunks after creating blob\n\n            try {\n              const float32Array = await processAudioBlob(audioBlob);\n              if (float32Array && isWorkerReady()) {\n                updateMicButtonState(mic, \"transcribing\", \"Transcribing...\"); // Update message\n                requestTranscription(float32Array, CONFIG.ASR_LANGUAGE);\n              } else if (!float32Array) {\n                console.error(\"Audio processing failed.\");\n                updateMicButtonState(mic, \"idle\", \"Audio processing failed\");\n              } else {\n                console.error(\"ASR worker not ready for transcription.\");\n                updateMicButtonState(mic, \"idle\", \"ASR worker not ready\");\n              }\n            } catch (procError) {\n              console.error(\"Error processing audio blob:\", procError);\n              updateMicButtonState(mic, \"idle\", \"Error processing audio\");\n            }\n          }; // --- End of onstop ---\n\n          mediaRecorder.onerror = (event: Event) => {\n            console.error(\"MediaRecorder Error:\", (event as ErrorEvent).error);\n            updateMicButtonState(mic, \"idle\", \"Recording error\");\n            stopRecording(true); // Force stop on error\n          };\n\n          mediaRecorder.start();\n          console.log(\"MediaRecorder started.\");\n        } catch (e: unknown) {\n          console.error(\"Failed to create MediaRecorder:\", e);\n          updateMicButtonState(mic, \"idle\", \"Recorder init failed\");\n          stopRecording(true); // Force stop\n        }\n      })\n      .catch((err: Error) => {\n        console.error(\"getUserMedia failed:\", err);\n        let message = \"Mic access denied or failed\";\n        if (err.name === \"NotAllowedError\")\n          message = \"Microphone access denied\";\n        else if (err.name === \"NotFoundError\") message = \"No microphone found\";\n        updateMicButtonState(mic, \"idle\", message); // Update state to idle with error message\n        stopRecording(true); // Ensure cleanup and hide cancel button\n      });\n  }\n\n  // --- Event Listeners ---\n\n  // Mousedown: Trigger initialization or start recording\n  mic.addEventListener(\"mousedown\", (e: MouseEvent) => {\n    if (e.button !== 0) return; // Only left click\n\n    // Set current instance context on any click/mousedown\n    if (chatInputContentEditable) {\n      setCurrentAsrInstance({ mic, chatInputContentEditable });\n    }\n\n    const status = currentAsrStatus; // Check global status from manager\n\n    console.log(\"Mousedown detected. ASR Status:\", status);\n\n    if (status === \"uninitialized\") {\n      console.log(\"ASR uninitialized, triggering initialization...\");\n      triggerASRInitialization(); // Request worker/model loading\n      // Update button state immediately to show loading feedback\n      updateMicButtonState(mic, \"idle\"); // Update state (will show loading based on global status)\n    } else if (status === \"ready\") {\n      console.log(\"ASR ready, starting recording...\");\n      startRecording(); // ASR is ready, proceed to record\n    } else if (status === \"loading\" || status === \"initializing\") {\n      console.log(\"ASR is currently loading/initializing. Please wait.\");\n      // Optionally provide feedback, though updateMicButtonState handles the visual\n      updateMicButtonState(mic, \"idle\"); // Refresh state to ensure spinner shows\n    } else if (status === \"error\") {\n      console.warn(\"Cannot start recording, ASR is in error state.\");\n      updateMicButtonState(mic, \"idle\"); // Refresh state to ensure error icon shows\n    } else {\n      // Handle other states like 'transcribing' - perhaps do nothing on mousedown\n      console.log(\"Mousedown ignored in current state:\", status);\n    }\n  });\n\n  // Mouseup: Stop recording if it was active\n  mic.addEventListener(\"mouseup\", (e: MouseEvent) => {\n    if (e.button !== 0) return;\n    // Check the button's state, not the global ASR status\n    if (mic.asrState === \"recording\") {\n      console.log(\"Mouseup detected while recording, stopping recording.\");\n      stopRecording(); // Stop normally, will trigger transcription\n    } else {\n      console.log(\"Mouseup detected, but not in recording state.\");\n    }\n  });\n\n  // Mouseleave: Cancel recording if mouse leaves while button is down\n  mic.addEventListener(\"mouseleave\", (e: MouseEvent) => {\n    // Check if left button is still pressed and the button state is recording\n    if (e.buttons === 1 && mic.asrState === \"recording\") {\n      console.log(\"Mouse left while recording, cancelling.\");\n      isCancelled = true; // Set cancel flag\n      stopRecording(true); // Force stop recording immediately\n      // State will be updated in the stopRecording/onstop logic now\n    }\n  });\n\n  // Click: Handle stop transcription button click\n  mic.addEventListener(\"click\", (e: MouseEvent) => {\n    // Stop transcription if the stop button is clicked\n    if (\n      (e.target as HTMLElement)?.classList.contains(\"stop-transcription-btn\")\n    ) {\n      e.stopPropagation(); // Prevent other mic click handlers\n      console.log(\"Stop transcription button clicked.\");\n      stopWorkerTranscription(); // Tell the worker to stop/discard\n      updateMicButtonState(mic, \"idle\", \"Transcription stopped\");\n      // Optionally clear the ASR target instance if needed\n      // clearCurrentAsrInstanceTarget();\n    }\n    // Note: We no longer need the check for !isWorkerReady() here\n    // because mousedown handles the initialization trigger.\n  });\n\n  // Cancel button event (Keep as is)\n  cancelBtn.addEventListener(\"click\", (e) => {\n    e.preventDefault();\n    e.stopPropagation();\n    if (mic.asrState === \"recording\") {\n      // Only act if currently recording\n      console.log(\"Cancel button clicked.\");\n      isCancelled = true;\n      stopRecording(true); // Force stop recording immediately\n      // State is updated within stopRecording/onstop now\n    }\n  });\n}\n\n// --- DOM Observer Setup ---\nexport function setupMicButtonObserver(): void {\n  // Listen for global status updates once at setup, mainly for initial state\n  const handleInitialStatus = (event: Event) => {\n    // Cast to CustomEvent to access detail if needed (optional)\n    const customEvent = event as CustomEvent<AsrStatusUpdateDetail>;\n    console.log(\n      \"Observer setup: Received initial ASR status\",\n      customEvent.detail\n    );\n    // Potentially update any existing buttons if needed, though initWave handles new ones\n    document\n      .querySelectorAll<HTMLElement>(DOM_SELECTORS.fullInputBox)\n      .forEach((el) => {\n        const mic = el.querySelector<MicButtonElement>(\".mic-btn\");\n        if (mic && mic.dataset.waveInit) {\n          // Only update if already initialized by initWave\n          updateMicButtonState(mic, mic.asrState || \"idle\");\n        }\n      });\n  };\n  document.addEventListener(\n    \"asrStatusUpdate\",\n    handleInitialStatus as EventListener,\n    {\n      once: true,\n    }\n  );\n\n  const obs = new MutationObserver((records) => {\n    records.forEach((r) => {\n      r.addedNodes.forEach((n) => {\n        if (n instanceof HTMLElement) {\n          if (n.matches(DOM_SELECTORS.fullInputBox)) {\n            initWave(n);\n          }\n          n.querySelectorAll<HTMLElement>(DOM_SELECTORS.fullInputBox).forEach(\n            (el) => {\n              // Check if already initialized to prevent duplicate listeners/DOM elements\n              if (!el.querySelector('.mic-btn[data-wave-init=\"1\"]')) {\n                initWave(el);\n              }\n            }\n          );\n        }\n      });\n      // Optional: Handle node removal for cleanup (remove event listeners)\n      // r.removedNodes.forEach(n => { ... });\n    });\n  });\n  obs.observe(document.documentElement, { childList: true, subtree: true });\n\n  // Initialize existing elements on load\n  document\n    .querySelectorAll<HTMLElement>(DOM_SELECTORS.fullInputBox)\n    .forEach((el) => {\n      if (!el.querySelector('.mic-btn[data-wave-init=\"1\"]')) {\n        initWave(el);\n      }\n    });\n\n  // Inject styles once\n  injectGlobalStyles();\n}\n", "import { getCurrentAsrInstance, setCurrentAsrInstance } from \"./asr/instance\";\nimport {\n  globalAsrMessage as currentAsrMessage,\n  initializeASRSystem,\n} from \"./asr/manager\";\nimport * as CONFIG from \"./config\";\nimport type {\n  AsrResultDetail,\n  AsrStatusUpdateDetail,\n  MicButtonElement,\n} from \"./types\";\nimport { DOM_SELECTORS } from \"./ui/dom-selectors\";\nimport { setupMicButtonObserver, updateMicButtonState } from \"./ui/mic-button\";\n\n// Define navigator with gpu property\ninterface NavigatorWithGPU extends Navigator {\n  gpu?: unknown;\n}\ndeclare const navigator: NavigatorWithGPU;\n\n(function () {\n  \"use strict\";\n\n  setCurrentAsrInstance(null);\n\n  // --- Check WebGPU Support ---\n  if (!navigator.gpu) {\n    console.warn(\"WebGPU not supported on this browser. ASR will not work.\");\n  }\n\n  // --- Load Transformers.js dynamically ---\n  let transformersLibLoaded = typeof window.transformers !== \"undefined\";\n\n  if (!transformersLibLoaded && typeof require !== \"undefined\") {\n    const scriptId = \"hf-transformers-script\";\n    if (!document.getElementById(scriptId)) {\n      console.log(\"Loading Hugging Face Transformers library...\");\n      const script = document.createElement(\"script\");\n      script.id = scriptId;\n      script.type = \"module\";\n      script.textContent = `\n              console.log('[ASR] Injected script block executing...');\n              console.log('[ASR] Attempting to load Transformers library...');\n              try {\n                  const { ${[\n                    \"AutoTokenizer\",\n                    \"AutoProcessor\",\n                    \"WhisperForConditionalGeneration\",\n                    \"TextStreamer\",\n                    \"full\",\n                    \"env\",\n                  ].join(\n                    \",\"\n                  )} } = await import('https://cdn.jsdelivr.net/npm/@huggingface/transformers@${\n        CONFIG.HUGGING_FACE_TRANSFORMERS_VERSION\n      }');\n                  console.log('[ASR] Transformers library imported successfully.');\n                  window.transformers = { AutoTokenizer, AutoProcessor, WhisperForConditionalGeneration, TextStreamer, full, env };\n                  window.transformers.env.backends.onnx.logLevel = 'info';\n                  console.log('[ASR] Transformers library loaded and configured.');\n                  document.dispatchEvent(new CustomEvent('transformersLoaded'));\n              } catch (error) {\n                  console.error(\"[ASR] Failed to load Hugging Face Transformers library:\", error);\n              }\n          `;\n      document.head.appendChild(script);\n    }\n  } else if (transformersLibLoaded && window.transformers) {\n    window.transformers.env.backends.onnx.logLevel = \"info\";\n  }\n\n  console.log(\"Initializing ASR system...\");\n  // Initialize the ASR system (creates worker, checks WebGPU, etc.)\n  initializeASRSystem();\n  console.log(\"ASR system initialized\");\n\n  // --- All Worker/UI/Audio logic moved to respective modules ---\n\n  // --- Global ASR Status Listener ---\n  document.addEventListener(\"asrStatusUpdate\", (e: Event) => {\n    console.log(\n      \"[ASR] Received asrStatusUpdate event:\",\n      (e as CustomEvent).detail\n    );\n    const _event = e as CustomEvent<AsrStatusUpdateDetail>;\n    // Update all mic buttons based on the new global state\n    document\n      .querySelectorAll<MicButtonElement>(\".mic-btn[data-asr-init]\")\n      .forEach((btn) => updateMicButtonState(btn, btn.asrState || \"idle\")); // updateMicButtonState is now imported\n  });\n\n  // --- Global ASR Result Handler ---\n  // Listens for results dispatched from asr/manager.ts\n  if (!window._asrGlobalHandlerAttached) {\n    // Store the last transcription to compare for incremental updates\n\n    function globalAsrResultHandler(e: Event) {\n      const event = e as CustomEvent<AsrResultDetail>;\n      const { status, output = \"\", data } = event.detail;\n\n      console.warn(\"[ASR] Received asrResult event:\", event.detail);\n      const asrInstance = getCurrentAsrInstance();\n      if (!asrInstance) return;\n      const { mic, chatInputContentEditable } = asrInstance;\n      const currentMicState = mic.asrState;\n      console.warn(\"Current mic state:\", currentMicState);\n      if (currentMicState === \"transcribing\") {\n        if (status === \"update\") {\n          /* generally we don't care about update chunks, but maybe we can do some fancy UI stuff? */\n        } else if (status === \"complete\") {\n          updateReactInput(chatInputContentEditable, output, false);\n\n          updateMicButtonState(mic, \"idle\");\n          chatInputContentEditable.focus();\n        } else if (status === \"error\") {\n          console.error(\"Transcription error:\", data);\n          updateMicButtonState(\n            mic,\n            \"idle\",\n            `Error: ${data || \"Unknown transcription error\"}`\n          );\n        } else if (status === \"transcribing_start\") {\n          // State is already transcribing\n        }\n      } else if (currentMicState === \"idle\" && status === \"error\") {\n        updateMicButtonState(\n          mic,\n          \"disabled\",\n          `ASR Error: ${data || currentAsrMessage}` // Use specific error or global one\n        );\n      }\n    }\n    document.addEventListener(\"asrResult\", globalAsrResultHandler);\n    window._asrGlobalHandlerAttached = true;\n  }\n\n  // --- Setup UI ---\n  // Initialize the MutationObserver and inject styles via the imported function\n  setupMicButtonObserver();\n\n  // Set asrInstance after UI is initialized\n  const mic = document.querySelector<MicButtonElement>(DOM_SELECTORS.micButton);\n  const chatInputContentEditable = document.querySelector<HTMLDivElement>(\n    DOM_SELECTORS.fullInputBox\n  );\n  if (mic && chatInputContentEditable) {\n    setCurrentAsrInstance({ mic, chatInputContentEditable });\n  }\n\n  /**\n   * Updates a React-controlled input by either replacing or appending text\n   * @param element The input element to update\n   * @param text The text to set/append\n   * @param shouldReplace Whether to replace existing text (true) or append (false)\n   */\n  function updateReactInput(\n    element: HTMLElement,\n    text: string,\n    shouldReplace: boolean = false\n  ) {\n    // Skip empty updates\n    if (text === \"\") {\n      return;\n    }\n\n    element.focus();\n\n    if (shouldReplace) {\n      // Don't update if nothing changed\n      if (element.textContent === text) {\n        return;\n      }\n\n      // Replace all content\n      const selection = window.getSelection();\n      const range = document.createRange();\n\n      // Select all existing content\n      range.selectNodeContents(element);\n      selection?.removeAllRanges();\n      selection?.addRange(range);\n\n      // @ts-ignore - document.execCommand is deprecated - but it's the only way to update the input value that worked\n      document.execCommand(\"insertText\", false, text);\n    } else {\n      // Append mode - check if we need to add a space before appending\n      const currentContent = element.textContent?.trim() || \"\";\n      let textToAppend = text;\n\n      // Add a space if:\n      // 1. There's existing content\n      // 2. The existing content doesn't already end with a space\n      // 3. The new text doesn't start with a space\n      if (currentContent.length > 0 && !text.startsWith(\" \")) {\n        textToAppend = \" \" + text;\n      }\n\n      // Move cursor to the end and insert\n      const selection = window.getSelection();\n      const range = document.createRange();\n\n      // Place cursor at the end of content\n      range.selectNodeContents(element);\n      range.collapse(false); // false means collapse to end\n      selection?.removeAllRanges();\n      selection?.addRange(range);\n\n      // @ts-ignore\n      document.execCommand(\"insertText\", false, textToAppend);\n    }\n\n    // Dispatch input event to ensure React knows about the change\n    const inputEvent = new Event(\"input\", { bubbles: true, cancelable: true });\n    element.dispatchEvent(inputEvent);\n  }\n})(); // End of IIFE\n"],
  "mappings": "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",
  "names": ["worker", "mic", "chatInputContentEditable"]
}
